#!/usr/bin/env raku

use v6;
use lib 'lib';

=begin pod

=head1 NAME

Clu - blah blah blah

=head1 SYNOPSIS

=begin code :lang<raku>

foo

=end code

=head1 DESCRIPTION

Clu is ...

=head1 AUTHOR

masukomi <masukomi@masukomi.org>

=head1 COPYRIGHT AND LICENSE

Copyright 2022 masukomi

This library is free software; you can redistribute it and/or modify it under the MIT License;

=end pod



# PROBABLE DEPENDENCIES
# Terminal::ANSIColor
# Text::MiscUtils
# Text::MiscUtils::Layout ( tables, columns, etc )
# TOML
# DB::SQLite (search)
# Color
# Test::Output
#

use DB::SQLite;

use Clu::Resourcer;
use Clu::Command;
use Clu::Ingester;
use Clu::Asciicaster;

#my %*SUB-MAIN-OPTS<named-anywhere> = True;

my proto sub MAIN(|) {*}
use CLI::Version $?DISTRIBUTION, &MAIN;

#| Add & updates documentation of a command with a .toml file, or an ansiicast demo with a .cast file
multi sub MAIN('add',
			   Str $path where / '.toml' $ |'.cast' $ / #= Paths must end in .toml or .cast
			  ) {
	ingest($path);
}

#| play the asciicast demo of the specified command
multi sub MAIN('demo', Str $command_name){
	guarantee-db();
	my $db = DB::SQLite.new(filename => "$*HOME/.config/clu/database.db", :readonly);
	unless demo-asciicast($command_name, $db) {
		note("Problems encountered running that demo.");
	}
}

#| Execute a full text against documented commands. Search terms should be separate arguments.
multi sub MAIN ('find', *@search_strings){
	guarantee-db();
	die("Search strings(s) must be provided") unless @search_strings.elems > 0;
	my $db = DB::SQLite.new(filename => "$*HOME/.config/clu/database.db", :readonly);
	my $search_string = @search_strings.join(' ');
	search-and-display($search_string, $db);

	$db.finish();

}

#| List all your commands & their quick description
multi sub MAIN ('list') {
	guarantee-db();
	my $db = DB::SQLite.new(filename => "$*HOME/.config/clu/database.db", :readonly);
	list-all-commands($db);
	$db.finish();
}

#| Remove a command from the database
multi sub MAIN ('remove', $command_name) {
	guarantee-db();
	my $db = DB::SQLite.new(filename => "$*HOME/.config/clu/database.db");
	remove-command($command_name, $db)
		?? say("$command_name has been removed")
		!! say("no command found with name $command_name");

	$db.finish();
}


#= Display the full details of a specific command
multi sub MAIN ('show', $command_name) {
	guarantee-db();
	my $db = DB::SQLite.new(filename => "$*HOME/.config/clu/database.db", :readonly);
	display-command($command_name, $db);

	$db.finish();
}

#| Generate a blank TOML template at the specified location.
multi sub MAIN('template', $destination) {
	say("Copying fresh template to $destination");
	copy(Clu::Resourcer.gimme{"template.meta.toml"}, $destination);
}


# #= display cheats for a command
# sub MAIN ('cheats', $command_name) {
#	my $db = DB::SQLite.new(filename => "$*HOME/.config/clu/database.db", :readonly)
# 	Clu::Cheats.new($command_name)
# 	# TODO: support interacting with the cheats
# 	# to choose one.
# 	# Then leveraging them as templates with params
# 	# that the user can fill in and have it executed.
# }

#| Updates documentation of a command with a .toml file, or an ansiicast demo with a .cast file
multi sub MAIN('update', Str $path) {ingest($path);}


#---------------
#internal stuff

sub ingest(Str $path) {
	guarantee-db();
	my $db = DB::SQLite.new(filename => "$*HOME/.config/clu/database.db");

	my $response;
	given $path {
		when .ends-with('.toml') {
			$response = ingest-metadata($path, $db);
		}
		when .ends-with('.cast') {
			$response = add-asciicast($path, $db);
		}
		default {
			my $warning = q:to/END/;
Added files must end with .toml or .cast.
.toml files should be TOML files similar to those produced
by clu template <path>
.cast files should be asciicast v2 files as produced by
asciinema recordings.
.cast files must have names that match the command they
are demonstrating. Ex. "my-hotness.cast" would be a demonstration
of the "my-hotness" command.
END
			warn($warning);
            exit(64); #  EX_USAGE (64) The command was used	incorrectly
		}
	}

	$db.finish;
	if $response {
		say("Successfully ingested $path");
		exit 0;
    } else {
	    note("Problems encountered ingesting $path");
		exit 1;
	}
}


sub copy-over-db($destination) {
	say("Copying fresh db to $destination");
	copy(Clu::Resourcer.gimme{"empty_database.db"}, $destination);
}

sub guarantee-db() returns Bool {
	my $dir = "$*HOME/.config/clu";
	my $path = "$dir/database.db";
	return True if $path.IO.e;
	unless $dir.IO.e {
		say("Creating $dir");
		mkdir($dir);
	}

	unless $path.IO.e {
		copy-over-db($path);
	}

	CATCH {
		when X::IO::Mkdir { die "Unable to create directory: $dir"; }
		when X::IO::Copy  { die "Unable to copy resource to $dir"; }
	}
}
