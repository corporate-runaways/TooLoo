#!/usr/bin/env raku

use v6;
use lib 'lib';

=begin pod

=head1 NAME

Clu - blah blah blah

=head1 SYNOPSIS

=begin code :lang<raku>

foo

=end code

=head1 DESCRIPTION

Clu is ...

=head1 AUTHOR

masukomi <masukomi@masukomi.org>

=head1 COPYRIGHT AND LICENSE

Copyright 2022 masukomi

This library is free software; you can redistribute it and/or modify it under the MIT License;

=end pod


use DB::SQLite;
use XDG::GuaranteedResources;

use Clu::Resourcer;
use Clu::Command;
use Clu::Ingester;
use Clu::Exporter;
use Clu::Asciicaster;

#my %*SUB-MAIN-OPTS<named-anywhere> = True;

my proto sub MAIN(|) {*}
use CLI::Version $?DISTRIBUTION, &MAIN;

#| Add & updates documentation of a command with a .toml file, or an ansiicast demo with a .cast file
multi sub MAIN('add',
			   Str $path where / '.toml' $ |'.cast' $ / #= Paths must end in .toml or .cast
			  ) {
	ingest($path);
}

#| play the asciicast demo of the specified command
multi sub MAIN('demo', Str $command_name){
	my $db = DB::SQLite.new(filename => guarantee-db(), :readonly);
	unless demo-asciicast($command_name, $db) {
		note("Problems encountered running that demo.");
	}
}
#| List all your commands that have associated asciicast demos
multi sub MAIN ('demos') {
	my $db = DB::SQLite.new(filename => guarantee-db(), :readonly);
	list-all-demos($db);
	$db.finish();
}

#| Execute a full text against documented commands. Search terms should be separate arguments.
multi sub MAIN ('find', *@search_strings){
	die("Search strings(s) must be provided") unless @search_strings.elems > 0;
	my $db = DB::SQLite.new(filename => guarantee-db(), :readonly);
	my $search_string = @search_strings.join(' ');
	search-and-display($search_string, $db);

	$db.finish();

}

#| List all your commands & their quick description
multi sub MAIN ('list') {
	my $db = DB::SQLite.new(filename => guarantee-db(), :readonly);
	list-all-commands($db);

	$db.finish();
}
#| Lists a filtered subset of commands via filter: 'demos'
multi sub MAIN ('list',
				Str $filter #= Currently supported filters: demos
			   ) {
	my $db = DB::SQLite.new(filename => guarantee-db(), :readonly);
	if $filter eq 'demos' {
		list-all-demos($db) ;
	} else {
		note("Unsupported list filter: $filter");
		note("Only 'demos' is currently supported.");
	}

	$db.finish();
}

#| Create a static blog documenting all your commands
multi sub MAIN ('export',
				Str $format,    #= Currently supported formats: hugo
				Str $directory  #= the directory to export to
				){
	my $cleaned_path = $directory.subst(/^^ "~"/, $*HOME);
	my $cp_io = $cleaned_path.IO;
	unless $cp_io.e {
		note("Target directory doesn't exist.\n$cleaned_path");
		# TODO: ask if we should create it.
		exit 64 # EX_USAGE
	}
	if $format eq 'hugo' {
		guarantee-md-templates();
		my $db = DB::SQLite.new(filename => guarantee-db(), :readonly);
		export-hugo($cp_io, $db);
		$db.finish();
	} else {
		note("Unsupported export format: $format");
		note("Only 'hugo' is currently supported.");
	}
}

#| Remove a command from the database
multi sub MAIN ('remove', $command_name) {
	my $db = DB::SQLite.new(filename => guarantee-db());
	remove-command($command_name, $db)
		?? say("$command_name has been removed")
		!! say("no command found with name $command_name");
}


#| Display the full details of a specific command
multi sub MAIN ('show',
				$command_name #= The name of the executable
			   ) {
	my $db = DB::SQLite.new(filename => guarantee-db(), :readonly);
	display-command($command_name, $db);
}

#| Generate a blank TOML template at the specified location.
multi sub MAIN('template', $destination) {
	my $template_path = "config/clu/template.meta.toml";
	my $resource_path = guarantee-resource($template_path, Clu::Resourcer);
	say("Copying fresh template to $destination");
	# NOTE: copying from the XDG path version in case the
	# use has modified the default template
	copy($resource_path, $destination);
}


# #= display cheats for a command
# sub MAIN ('cheats', $command_name) {
#	my $db = DB::SQLite.new(filename => guarantee-db(), :readonly)
# 	Clu::Cheats.new($command_name)
# 	# TODO: support interacting with the cheats
# 	# to choose one.
# 	# Then leveraging them as templates with params
# 	# that the user can fill in and have it executed.
# }

#| Updates documentation of a command with a .toml file, or an ansiicast demo with a .cast file
multi sub MAIN('update', Str $path) {ingest($path);}


#---------------
#internal stuff

sub ingest(Str $path) {
	my $db = DB::SQLite.new(filename => guarantee-db(),
						   busy-timeout => 3000);

	my $response;
	given $path {
		when .ends-with('.toml') {
			$response = ingest-metadata($path, $db);
		}
		when .ends-with('.cast') {
			$response = add-asciicast($path, $db);
		}
		default {
			my $warning = q:to/END/;
Added files must end with .toml or .cast.
.toml files should be TOML files similar to those produced
by clu template <path>
.cast files should be asciicast v2 files as produced by
asciinema recordings.
.cast files must have names that match the command they
are demonstrating. Ex. "my-hotness.cast" would be a demonstration
of the "my-hotness" command.
END
			warn($warning);
            exit(64); #  EX_USAGE (64) The command was used	incorrectly
		}
	}

	if $response {
		say("Successfully ingested $path");
		exit 0;
    } else {
		note qq:to/END/;

		NOTE:
		If the preceeding message didn't make the solution obvious:

		Problems were encountered ingesting $path
		Please confirm that it's valid TOML.
		toml-cli is a good tool for quickly sanity checking your TOML files
		https://crates.io/crates/toml-cli
		run the following to see what it has to say
		toml get $path .
		END

		exit 1;
	}
}



sub guarantee-db() returns Str {
	my $db_path = "data/clu/database.db";
	my $resource_path = guarantee-resource($db_path, Clu::Resourcer);

	return $resource_path;
}

sub guarantee-md-templates() {
	for ("config/clu/markdown_details_template.tt",
		 "config/clu/markdown_index_template.tt") -> $path {
		guarantee-resource($path, Clu::Resourcer);
	}
}
